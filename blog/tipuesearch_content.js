var tipuesearch = {"pages":[{"tags":"misc","url":"./pages/about/","title":"About","text":"2016Fall 修課成員網誌"},{"tags":"Course","url":"./ren-zhong-zhi-long-6-sheng-ming-zhi-shi.html","title":"人中之龍6 生命之詩","text":"龍が如く"},{"tags":"Course","url":"./dan-xian-xuan-zhuan-dong-hua.html","title":"單線旋轉動畫","text":"單線旋轉動畫: window.onload=function(){ brython(1); } from browser import document from browser import window from browser import timer import math canvas = document[\"onebar\"] ctx = canvas.getContext(\"2d\") # 取畫布的寬與高度 width = canvas.width height = canvas.height # 畫圓函式 def circle(x,y,r): ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) ctx.fill() ctx.closePath() def line(x1, y1, x2, y2): # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() line(200, 200, 200, 300) circle(200, 200, 5) x1 = 200 y1 = 200 r = 100 deg = math.pi/180 theta = 0 # 每隔特定時間, 進行動畫繪製 def animate(): global theta # 刷新畫布 ctx.clearRect(0, 0, width, height) # 逐一重新繪製直線與圓心球 x2 = x1 + r*math.cos(theta*deg) y2 = y1 + r*math.sin(theta*deg) line(x1, y1, x2, y2) # 再加一條小線段 x3 = x2 + 50*math.cos(10*theta*deg) y3 = y2 + 50*math.sin(10*theta*deg) line(x2, y2, x3, y3) circle(x1, y1, 5) theta += 1 timer.set_interval(animate, 50) 上述繪圖的程式碼如下: window.onload=function(){ brython(1); } from browser import document from browser import window from browser import timer import math canvas = document[\"onebar\"] ctx = canvas.getContext(\"2d\") # 取畫布的寬與高度 width = canvas.width height = canvas.height # 畫圓函式 def circle(x,y,r): ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) ctx.fill() ctx.closePath() def line(x1, y1, x2, y2): # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() line(200, 200, 200, 300) circle(200, 200, 5) x1 = 200 y1 = 200 r = 100 deg = math.pi/180 theta = 0 # 每隔特定時間, 進行動畫繪製 def animate(): global theta # 刷新畫布 ctx.clearRect(0, 0, width, height) # 逐一重新繪製直線與圓心球 x2 = x1 + r*math.cos(theta*deg) y2 = y1 + r*math.sin(theta*deg) line(x1, y1, x2, y2) # 再加一條小線段 x3 = x2 + 50*math.cos(10*theta*deg) y3 = y2 + 50*math.sin(10*theta*deg) line(x2, y2, x3, y3) circle(x1, y1, 5) theta += 1 timer.set_interval(animate, 50)"},{"tags":"Course","url":"./ping-mian-ji-gou-mo-ni.html","title":"平面機構模擬","text":"四連桿機構運動模擬: canvas { border: 1px solid black; } window.onload=function(){ brython(1); } from browser import document from browser import window from browser import timer from javascript import JSConstructor import math # 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 JSConstructor 函式轉為 Brython 變數 pdraw = JSConstructor(window.PrairieDraw) # 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 JSConstructor 函式轉為 Brython 變數 PrairieDrawAnim = JSConstructor(window.PrairieDrawAnim) # 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數 # 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用 vector = window.Vector.create # 在 \"fourbar\" 畫布中建立 panim 動態模擬案例 panim = PrairieDrawAnim(\"fourbar\") # 平面連桿繪圖以 t = 0 起始 t = 0 # 控制轉動方向變數 direction = True # 繪製不同 t 時間下的平面連桿 def draw(): global t, direction, fast # 設定模擬繪圖範圍 panim.setUnits(6, 6) # 設定箭頭線寬 panim.setProp(\"arrowLineWidthPx\",2) # 起始變數設定 omega = 1 length_bar1 = 1 length_bar2 = 26/18 length_bar3 = 2 length_base = 40/18 time = 0 # 畫出地面直線 G = vector([0, -0.5]) panim.ground(G, vector([0, 1]), 10) # 連桿長度與角度計算 A = t*omega # \"theta\" AD = length_bar1 #length of left bar AB = length_base #distance between two stationary pivots BC = length_bar3 #length of right bar CD = length_bar2 #length of middle bar BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A)) C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD)) ABD = math.asin(CD * math.sin(C) / BD) DBC = math.asin(AD * math.sin(A) / BD) B = ABD + DBC D = math.pi - B - C # draw pivot pivot_left = vector([AB/-2, 0]) pivot_right = vector([AB/2, 0]) panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5) panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5) # 儲存轉換矩陣 panim.save() #FIRST BAR panim.translate(pivot_left) panim.rotate(A) panim.rod(vector([0,0]), vector([AD,0]), 0.25) panim.point(vector([0,0])) #SECOND BAR panim.translate(vector([AD,0])) panim.rotate(A*-1) #\"undo\" the original A rotation panim.rotate(D) #rotate by D only panim.rod(vector([0,0]), vector([CD,0]), 0.25) panim.point(vector([0,0])) #THIRD BAR panim.translate(vector([CD,0])) panim.rotate(math.pi+C) panim.rod(vector([0,0]), vector([BC,0]), 0.25) panim.point(vector([0,0])) # 回復原先的轉換矩陣 panim.restore() panim.point(vector([pivot_right.e(1), 0])) # 時間增量 if direction == True: t += 0.08 else: t += -0.08 # 先畫出 t = 0 的連桿機構 draw() # 將 anim 設為 None anim = None def launchAnimation(ev): global anim # 初始啟動, anim 為 None if anim is None: # 每 0.08 秒執行一次 draw 函式繪圖 anim = timer.set_interval(draw, 80) # 初始啟動後, 按鈕文字轉為\"暫停\" document['power'].text = '暫停' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為\"暫停\" anim = timer.set_interval(draw, 80) document['power'].text = '暫停' else: # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停 # 且將 anim 變數設為 'hold', 且 power 文字轉為\"繼續\" timer.clear_interval(anim) anim = 'hold' document['power'].text = '繼續' def reverse(ev): global anim, direction # 當 anim 為 hold 時, 按鈕無效 if anim != \"hold\": if direction == True: direction = False else: direction = True document[\"power\"].bind(\"click\", launchAnimation) document[\"reverse\"].bind(\"click\", reverse) 啟動 反向 canvas { border: 1px solid black; } window.onload=function(){ brython(1); } from browser import document from browser import window from browser import timer from javascript import JSConstructor import math # 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 JSConstructor 函式轉為 Brython 變數 pdraw = JSConstructor(window.PrairieDraw) # 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 JSConstructor 函式轉為 Brython 變數 PrairieDrawAnim = JSConstructor(window.PrairieDrawAnim) # 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數 # 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用 vector = window.Vector.create # 在 \"fourbar\" 畫布中建立 panim 動態模擬案例 panim = PrairieDrawAnim(\"fourbar\") # 平面連桿繪圖以 t = 0 起始 t = 0 # 控制轉動方向變數 direction = True # 繪製不同 t 時間下的平面連桿 def draw(): global t, direction, fast # 設定模擬繪圖範圍 panim.setUnits(6, 6) # 設定箭頭線寬 panim.setProp(\"arrowLineWidthPx\",2) # 起始變數設定 omega = 1 length_bar1 = 1 length_bar2 = 26/18 length_bar3 = 2 length_base = 40/18 time = 0 # 畫出地面直線 G = vector([0, -0.5]) panim.ground(G, vector([0, 1]), 10) # 連桿長度與角度計算 A = t*omega # \"theta\" AD = length_bar1 #length of left bar AB = length_base #distance between two stationary pivots BC = length_bar3 #length of right bar CD = length_bar2 #length of middle bar BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A)) C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD)) ABD = math.asin(CD * math.sin(C) / BD) DBC = math.asin(AD * math.sin(A) / BD) B = ABD + DBC D = math.pi - B - C # draw pivot pivot_left = vector([AB/-2, 0]) pivot_right = vector([AB/2, 0]) panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5) panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5) # 儲存轉換矩陣 panim.save() #FIRST BAR panim.translate(pivot_left) panim.rotate(A) panim.rod(vector([0,0]), vector([AD,0]), 0.25) panim.point(vector([0,0])) #SECOND BAR panim.translate(vector([AD,0])) panim.rotate(A*-1) #\"undo\" the original A rotation panim.rotate(D) #rotate by D only panim.rod(vector([0,0]), vector([CD,0]), 0.25) panim.point(vector([0,0])) #THIRD BAR panim.translate(vector([CD,0])) panim.rotate(math.pi+C) panim.rod(vector([0,0]), vector([BC,0]), 0.25) panim.point(vector([0,0])) # 回復原先的轉換矩陣 panim.restore() panim.point(vector([pivot_right.e(1), 0])) # 時間增量 if direction == True: t += 0.08 else: t += -0.08 # 先畫出 t = 0 的連桿機構 draw() # 將 anim 設為 None anim = None def launchAnimation(ev): global anim # 初始啟動, anim 為 None if anim is None: # 每 0.08 秒執行一次 draw 函式繪圖 anim = timer.set_interval(draw, 80) # 初始啟動後, 按鈕文字轉為\"暫停\" document['power'].text = '暫停' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為\"暫停\" anim = timer.set_interval(draw, 80) document['power'].text = '暫停' else: # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停 # 且將 anim 變數設為 'hold', 且 power 文字轉為\"繼續\" timer.clear_interval(anim) anim = 'hold' document['power'].text = '繼續' def reverse(ev): global anim, direction # 當 anim 為 hold 時, 按鈕無效 if anim != \"hold\": if direction == True: direction = False else: direction = True document[\"power\"].bind(\"click\", launchAnimation) document[\"reverse\"].bind(\"click\", reverse) 啟動 反向"},{"tags":"Course","url":"./xin-nian-kuai-le.html","title":"新年快樂","text":"2017 年元旦快樂 首先了解 random 亂數模組的用法 然後利用 random 模組產生一個介於 1-100 的整數, 列印在網頁上. window.onload=function(){ brython(1); } from browser import document from browser import html import random print_location = document[\"newyear\"] def gen_int(): num = random.randint(1, 49) # 設法將 num 列印在網頁上 #print_location = document[\"newyear\"] print_location <= num + html.BR() def lottery(e): for i in range(6): gen_int() print_location <= \"(可能重複)恭喜中獎!\" + html.BR() #document[\"but1\"].bind(\"click\", gen_int) document[\"but1\"].bind(\"click\", lottery) 產生 1-49 整數亂數 (可能重複) from browser import document from browser import html import random print_location = document[\"newyear\"] def gen_int(): num = random.randint(1, 49) # 設法將 num 列印在網頁上 #print_location = document[\"newyear\"] print_location <= num + html.BR() def lottery(e): for i in range(6): gen_int() print_location <= \"(可能重複)恭喜中獎!\" + html.BR() #document[\"but1\"].bind(\"click\", gen_int) document[\"but1\"].bind(\"click\", lottery) 產生 1-49 整數亂數 (可能重複) 因為上述程式可能會產生相同的號碼, 改用 random.sample() , 使其產生六個不同的整數!! from browser import document from browser import html import random print_location = document[\"newyear\"] def lottery(e): num_list = random.sample(list(range(1, 50)), 6) for i in range(6): print_location <= num_list[i] + html.BR() print_location <= \"(不會重複)恭喜中獎!\" + html.BR() document[\"but2\"].bind(\"click\", lottery) (不會重複)恭喜中獎 from browser import document from browser import html import random print_location = document[\"newyear\"] def lottery(e): num_list = random.sample(list(range(1, 50)), 6) for i in range(6): print_location <= num_list[i] + html.BR() print_location <= \"(不會重複)恭喜中獎!\" + html.BR() document[\"but2\"].bind(\"click\", lottery) 恭喜中獎 以下建立一個猜數字遊戲: from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲 from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲 以下則利用程式執行猜數字遊戲: 利用程式玩猜數字 from browser import document from browser import html import random id4 = document[\"id4\"] def autoguess(ev): 執行次數 = 100 總猜測次數 = 0 for i in range(執行次數): id4 <= \"第\" + str(i+1) + \"次玩:\" + html.BR() 下限 = 1 上限 = 100 標準答案 = random.randint(下限, 上限) pc猜的數字 = random.randint(下限, 上限) #print(標準答案, pc猜的數字) #integer int() #string str() #float float() #你猜的數字 = int(input(\"請輸入您所猜的整數:\")) 猜測次數 = 1 while 標準答案 != pc猜的數字: if 標準答案 < pc猜的數字: #print(\"太大了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 - 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太大了!\" + html.BR() 上限 = pc猜的數字 - 1 else: #print(\"太小了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 + 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太小了!\" + html.BR() 下限 = pc猜的數字 + 1 #pc猜的數字 = int(input(\"請輸入您所猜的整數:\")) pc猜的數字 = random.randint(下限, 上限) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id4 <= \"電腦猜對了, 答案為: \" + str(標準答案) + \", 總共猜了 \"+ str(猜測次數) + \"次\" + html.BR() 總猜測次數 += 猜測次數 平均猜測次數 = int(總猜測次數/執行次數) #print(\"平均次數\", 平均猜測次數) id4 <= \"平均次數: \" + str(平均猜測次數) document[\"but4\"].bind(\"click\", autoguess) from browser import document from browser import html import random id4 = document[\"id4\"] def autoguess(ev): 執行次數 = 100 總猜測次數 = 0 for i in range(執行次數): id4 <= \"第\" + str(i+1) + \"次玩:\" + html.BR() 下限 = 1 上限 = 100 標準答案 = random.randint(下限, 上限) pc猜的數字 = random.randint(下限, 上限) #print(標準答案, pc猜的數字) #integer int() #string str() #float float() #你猜的數字 = int(input(\"請輸入您所猜的整數:\")) 猜測次數 = 1 while 標準答案 != pc猜的數字: if 標準答案 < pc猜的數字: #print(\"太大了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 - 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太大了!\" + html.BR() 上限 = pc猜的數字 - 1 else: #print(\"太小了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 + 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太小了!\" + html.BR() 下限 = pc猜的數字 + 1 #pc猜的數字 = int(input(\"請輸入您所猜的整數:\")) pc猜的數字 = random.randint(下限, 上限) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id4 <= \"電腦猜對了, 答案為: \" + str(標準答案) + \", 總共猜了 \"+ str(猜測次數) + \"次\" + html.BR() 總猜測次數 += 猜測次數 平均猜測次數 = int(總猜測次數/執行次數) #print(\"平均次數\", 平均猜測次數) id4 <= \"平均次數: \" + str(平均猜測次數) document[\"but4\"].bind(\"click\", autoguess) 利用程式玩猜數字"},{"tags":"Course","url":"./ye-dan-kuai-le.html","title":"耶誕快樂","text":"耶誕快樂 window.onload=function(){ brython(1); } from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 try: if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() except: c <= \"請輸入整數!!\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 try: if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() except: c <= \"請輸入整數!!\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa"},{"tags":"Course","url":"./w12-brython-hui-tu-lian-xi.html","title":"W12 Brython 繪圖練習","text":"Brython 繪圖 繪圖流程, 導入程式庫, 啟動, 然後引用各種模組開始繪圖. 以下利用函式定義進行和弦底稿繪圖: window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() w = 20 h = 30 background(100, 100, w, h, 5, 5, ctx) mylist = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] num = 0 for s in mylist: #canvasText(100, 80, 20, \"A\", \"b\", \"\", \"black\", ctx) canvasText(100+num*w, 80, 20, s, \"\", \"\", \"black\", ctx) num = num + 1 上述繪圖的程式碼: window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() w = 20 h = 30 background(100, 100, w, h, 5, 5, ctx) canvasText(100, 80, 20, \"A\", \"b\", \"\", \"black\", ctx)"},{"tags":"Course","url":"./w11-brython-hui-tu-fan-li.html","title":"W11 Brython 繪圖範例","text":"Brython 繪圖 繪圖流程, 導入程式庫, 啟動, 然後引用各種模組開始繪圖 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") ''' # 改用 background 函式繪圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ''' def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() # 設法利用運算印出吉他各把位的音名 def doreme(x, y, fontSize, order, ctx): # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) #簡譜 1 2 3 4 5 6 7 #音名 C D E F G A B #唱名 Do Re Mi Fa Sol La Ti # 讓音名數列可以每 12 音名後, 升高 key 後從頭開始 if order > 12: order = order % 12 if order == 1: canvasText(x, y, fontSize, \"A\", \"\", \"\", \"black\", ctx) elif order ==2: canvasText(x, y, fontSize, \"B\", \"b\", \"\", \"red\", ctx) elif order == 3: canvasText(x, y, fontSize, \"B\", \"\", \"\", \"black\", ctx) elif order == 4: canvasText(x, y, fontSize, \"C\", \"\", \"\", \"black\", ctx) elif order == 5: canvasText(x, y, fontSize, \"D\", \"b\", \"\", \"red\", ctx) elif order == 6: canvasText(x, y, fontSize, \"D\", \"\", \"\", \"black\", ctx) elif order == 7: canvasText(x, y, fontSize, \"E\", \"b\", \"\", \"red\", ctx) elif order == 8: canvasText(x, y, fontSize, \"E\", \"\", \"\", \"black\", ctx) elif order == 9: canvasText(x, y, fontSize, \"F\", \"\", \"\", \"black\", ctx) elif order == 10: canvasText(x, y, fontSize, \"G\", \"b\", \"\", \"red\", ctx) elif order == 11: canvasText(x, y, fontSize, \"G\", \"\", \"\", \"black\", ctx) elif order == 12: canvasText(x, y, fontSize, \"A\", \"b\", \"\", \"red\", ctx) else: canvasText(x, y, fontSize, \"Error\", \"\", \"\", \"red\", ctx) def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"20px Arial\" sixString = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] stringNum = 0 for i in sixString: ctx.fillText(i, x-7+stringNum*xinc, y-30) stringNum = stringNum + 1 ctx.fill() ctx.stroke() ctx.closePath() # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) canvasText(x, y-50, 20, \"A\", \"\", \"\", \"black\", ctx) canvasText(x+xinc, y-50, 20, \"B\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*2, y-50, 20, \"B\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*3, y-50, 20, \"C\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*4, y-50, 20, \"D\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*5, y-50, 20, \"D\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*6, y-50, 20, \"E\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*7, y-50, 20, \"E\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*8, y-50, 20, \"F\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*9, y-50, 20, \"G\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*10, y-50, 20, \"G\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*11, y-50, 20, \"A\", \"b\", \"\", \"red\", ctx) #################################### # 以下利用數列運算, 從已知第1把位的音名分別推算各把位的音名 # 吉他初始音名次序 816(11)38 #################################### firstBar = [8, 1, 6, 11, 3, 8] # j 為往下增量 for j in range(4): # k 為 往右把位初始值 fontSize = 15 for k in range(6): bx = x + (k)*w - fontSize/3 by = y + (j)*h+h/2 + fontSize/2 order = firstBar[k] + j + 1 doreme(bx, by, fontSize, order, ctx) # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by #def ball(x, y, w, h , wcoord, hcoord, r, color, ctx): def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() #ctx.fillStyle = 'black' ctx.fillStyle = color #ctx.strokeStyle = \"black\" ctx.strokeStyle = color #ctx.arc(50, 80, 9, 0, 2*math.pi, False) ctx.arc(bx, by, r2, 0, 2*math.pi, False) # 為了疊上各把位的音名, 暫時不填色 #ctx.fill() ctx.stroke() ctx.closePath() x = 300 y = 200 w = 20 h = 30 # 將前面的水平線與垂直線繪圖改用 background 繪圖 background(100, 100, w, h, 5, 4, ctx) background(x, y, w, h, 5, 4, ctx) #background(100, 300, 10, 10, 5, 4, ctx) #background(300, 100, 10, 10, 5, 12, ctx) # 配合 300, 300 的和絃背景, w=30, h=30, (1,1) 位置放入圓 for i in range( 6): for j in range(3): ball(x, y, w, h, i+1, j+1, 'black', ctx) ball(x, y, w, h, 1, 4, 'red', ctx) #ball(300, 300, 30, 20, 1, 1, 9, 'black', ctx) 上述繪圖第一部分使用迴圈繪製水平線與垂直線: from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() 至於將繪圖內容納入 def 函式定義格式後: from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() background(300, 300, 10, 10, 5, 4, ctx) background(100, 300, 10, 10, 5, 4, ctx) background(300, 100, 10, 10, 5, 12, ctx) 之後進一步將 background 與 ball 配合進行函式設計後: def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by # r 最後配合 w 與 h 較小的值進行運算 def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color ctx.arc(bx, by, r2, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() # 利用 x, y 定義和弦左上角座標, 放入的圓也必須配合此一座標運算 x = 300 y = 200 w = 20 h = 30 background(x, y, w, h, 5, 4, ctx) for i in range( 6): for j in range(3): ball(x, y, w, h, i+1, j+1, 'black', ctx) ball(x, y, w, h, 1, 4, 'red', ctx) 註記: 其實使用 html5 CANVAS , 以 png 格式繪製吉他和弦圖, 只是為了讓 Python3 的初學者熟悉變數、數列、迴圈、函式與類別的基本計算機程式語法. 就實用上, 應該要使用 Python3 程式建立 SVG 向量圖. http://www.joebrown.org.uk/wp/?p=8553 就是採用 Python2 與 MySQL 資料庫建立大量的吉他和絃 SVG 圖, 將這個程式改為 Python3 並且配合網際應用 (Flask), 建立一套可以利用程式方法建立各式歌曲的吉他和絃譜, 並且結合 MIDI 或機械手彈奏, 應該是一系列不錯的專題應用."},{"tags":"Course","url":"./w10-brython-hui-tu-fan-li.html","title":"W10 Brython 繪圖範例","text":"Brython 繪圖 繪圖流程, 導入程式庫, 啟動, 然後引用各種模組開始繪圖 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag1\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (100, 100) 座標點 ctx.moveTo(100, 100) # 然後畫直線到 (150, 200) 座標點 ctx.lineTo(150, 200) # 畫右上左下的斜線 ctx.moveTo(150, 100) ctx.lineTo(100, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag2\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 for i in range(5): ctx.moveTo(100+i*10, 100) ctx.lineTo(100+i*10, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() from browser import document as doc from browser import html import math import re # 準備繪圖畫布 canvas = doc[\"japanflag3\"] container = doc[\"container3\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 1 與 A7 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"A7\", 100, 70) ctx.arc(50, 50, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 45, 55) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(50, 80, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 45, 85) ctx.fill() ctx.stroke() ctx.closePath() # 4 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(50, 110, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"4\", 45, 115) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(50, 140, 7, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 170, 7, 0, 2*math.pi, False) ctx.moveTo(44, 164) ctx.lineTo(56, 176) ctx.moveTo(56, 164) ctx.lineTo(44, 176) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ''' # 以下將 canvas 畫布內容轉為 img tag, 並且顯示在 container 物件 img = canvas.toDataURL(\"image/png\") # 利用 re.sub, 將原本要直接開圖檔的 data:image 標頭, 改為 data:application/octet-stream, 可直接下載存檔 # 使用 re 模組之前必須先 import re img = re.sub(\"&#94;data:image\\/[&#94;;]\", \"data:application/octet-stream\", img) # 宣告 anchor markup attribute download, 可以指定下載儲存檔名 container <= html.A(\"save image\", href=img, download=\"guitar_chord.png\") ''' 請注意, 開發 Brython 程式時, 建議使用 Firefox 開啟網誌, 因為反應速度較 Chrome 快速. 請各組利用上列程式範例片段, 完成下列和弦繪圖: ''' from browser import document from browser.timer import request_animation_frame import math import time canvas = document['stage'] ctx = canvas.getContext('2d') ticks = 0 x = 0.0 def mouse_moved(ev): global x new_x = ev.clientX - (canvas.width / 2) + 25 if new_x > 50 and new_x < canvas.width - 100: x = new_x canvas.bind(\"mousemove\", mouse_moved) def clear(): ctx.save() ctx.setTransform(1, 0, 0, 1, 0, 0) ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.restore() def draw(): global ticks ticks += 1 clear() y = (150 * math.sin(ticks / 50)) + 150 ctx.fillStyle = \"blue\" ctx.fillRect(x, y, 100.0, 100.0) ctx.fill() def animate(i): global id id = request_animation_frame(animate) draw() animate(0) '''"},{"tags":"Misc","url":"./2016fall-yan-bo-sheng.html","title":"2016Fall 嚴伯陞","text":"2016-11-15_18-58-57 from s40523148 on Vimeo . 網誌 Category 網誌 Tags reveal.js 使用導引"}]};